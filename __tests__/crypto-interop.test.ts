/**
 * Cross-platform crypto interop test (mobile).
 *
 * Verifies that the JavaScript crypto implementation (@noble/*) produces
 * output compatible with the Rust llamenos-core implementation by consuming
 * test vectors generated by `llamenos-core/tests/interop.rs`.
 *
 * Run the Rust test first to generate vectors:
 *   cd ../llamenos-core && cargo test --test interop
 *
 * Then run this test:
 *   bun run test:unit
 */

import { readFileSync } from 'fs'
import { resolve } from 'path'
import { sha256 } from '@noble/hashes/sha2.js'
import { xchacha20poly1305 } from '@noble/ciphers/chacha.js'
import { bytesToHex, hexToBytes, utf8ToBytes } from '@noble/hashes/utils.js'
import { secp256k1, schnorr } from '@noble/curves/secp256k1.js'
import { hkdf } from '@noble/hashes/hkdf.js'
import * as labels from '../src/lib/crypto-labels'

const VECTORS_PATH = resolve(__dirname, 'fixtures/test-vectors.json')
const vectors = JSON.parse(readFileSync(VECTORS_PATH, 'utf-8'))

// ─── Helpers ─────────────────────────────────────────────────

/** ECIES unwrap: ECDH -> SHA-256(label || sharedX) -> XChaCha20-Poly1305 */
function eciesUnwrap(
  envelope: { wrappedKey: string; ephemeralPubkey: string },
  secretKeyHex: string,
  label: string,
): Uint8Array {
  const wrappedBytes = hexToBytes(envelope.wrappedKey)
  const nonce = wrappedBytes.slice(0, 24)
  const ciphertext = wrappedBytes.slice(24)
  const ephPubkey = hexToBytes(envelope.ephemeralPubkey)

  const sharedPoint = secp256k1.getSharedSecret(hexToBytes(secretKeyHex), ephPubkey)
  const sharedX = sharedPoint.slice(1, 33)

  const keyMaterial = new Uint8Array([...utf8ToBytes(label), ...sharedX])
  const symmetricKey = sha256(keyMaterial)

  const cipher = xchacha20poly1305(symmetricKey, nonce)
  return cipher.decrypt(ciphertext)
}

/** Decrypt hex(nonce24 + ciphertext) with a symmetric key */
function decryptContent(encryptedContentHex: string, key: Uint8Array): string {
  const contentBytes = hexToBytes(encryptedContentHex)
  const nonce = contentBytes.slice(0, 24)
  const ciphertext = contentBytes.slice(24)

  const cipher = xchacha20poly1305(key, nonce)
  const plaintext = cipher.decrypt(ciphertext)
  return new TextDecoder().decode(plaintext)
}

// ─── Tests ───────────────────────────────────────────────────

describe('Cross-platform crypto interop', () => {
  test('label constants match Rust', () => {
    const rustLabels = vectors.labels

    expect(labels.LABEL_NOTE_KEY).toBe(rustLabels.labelNoteKey)
    expect(labels.LABEL_FILE_KEY).toBe(rustLabels.labelFileKey)
    expect(labels.LABEL_FILE_METADATA).toBe(rustLabels.labelFileMetadata)
    expect(labels.LABEL_HUB_KEY_WRAP).toBe(rustLabels.labelHubKeyWrap)
    expect(labels.LABEL_TRANSCRIPTION).toBe(rustLabels.labelTranscription)
    expect(labels.LABEL_MESSAGE).toBe(rustLabels.labelMessage)
    expect(labels.LABEL_CALL_META).toBe(rustLabels.labelCallMeta)
    expect(labels.LABEL_SHIFT_SCHEDULE).toBe(rustLabels.labelShiftSchedule)
    expect(labels.HKDF_SALT).toBe(rustLabels.hkdfSalt)
    expect(labels.HKDF_CONTEXT_NOTES).toBe(rustLabels.hkdfContextNotes)
    expect(labels.HKDF_CONTEXT_DRAFTS).toBe(rustLabels.hkdfContextDrafts)
    expect(labels.HKDF_CONTEXT_EXPORT).toBe(rustLabels.hkdfContextExport)
    expect(labels.LABEL_HUB_EVENT).toBe(rustLabels.labelHubEvent)
    expect(labels.LABEL_DEVICE_PROVISION).toBe(rustLabels.labelDeviceProvision)
    expect(labels.SAS_SALT).toBe(rustLabels.sasSalt)
    expect(labels.SAS_INFO).toBe(rustLabels.sasInfo)
    expect(labels.AUTH_PREFIX).toBe(rustLabels.authPrefix)
    expect(labels.HMAC_PHONE_PREFIX).toBe(rustLabels.hmacPhonePrefix)
    expect(labels.HMAC_IP_PREFIX).toBe(rustLabels.hmacIpPrefix)
    expect(labels.HMAC_KEYID_PREFIX).toBe(rustLabels.hmacKeyidPrefix)
    expect(labels.HMAC_SUBSCRIBER).toBe(rustLabels.hmacSubscriber)
    expect(labels.HMAC_PREFERENCE_TOKEN).toBe(rustLabels.hmacPreferenceToken)
    expect(labels.RECOVERY_SALT).toBe(rustLabels.recoverySalt)
    expect(labels.LABEL_BACKUP).toBe(rustLabels.labelBackup)
    expect(labels.LABEL_SERVER_NOSTR_KEY).toBe(rustLabels.labelServerNostrKey)
    expect(labels.LABEL_SERVER_NOSTR_KEY_INFO).toBe(rustLabels.labelServerNostrKeyInfo)
    expect(labels.LABEL_PUSH_WAKE).toBe(rustLabels.labelPushWake)
    expect(labels.LABEL_PUSH_FULL).toBe(rustLabels.labelPushFull)
  })

  test('JS derives same pubkey from test secret key', () => {
    const secretKeyHex = vectors.keys.secretKeyHex
    const expectedPubkey = vectors.keys.publicKeyHex

    // Derive x-only pubkey (BIP-340 style) -- v2 requires Uint8Array input
    const fullPubkey = secp256k1.getPublicKey(hexToBytes(secretKeyHex), true) // compressed
    // x-only = drop the 02/03 prefix
    const xOnlyHex = bytesToHex(fullPubkey.slice(1))

    expect(xOnlyHex).toBe(expectedPubkey)
  })

  test('JS derives same admin pubkey', () => {
    const secretKeyHex = vectors.keys.adminSecretKeyHex
    const expectedPubkey = vectors.keys.adminPublicKeyHex

    const fullPubkey = secp256k1.getPublicKey(hexToBytes(secretKeyHex), true)
    const xOnlyHex = bytesToHex(fullPubkey.slice(1))

    expect(xOnlyHex).toBe(expectedPubkey)
  })

  test('JS can unwrap ECIES envelope produced by Rust', () => {
    const { envelope, originalKeyHex, label } = vectors.ecies
    const adminSecretKey = vectors.keys.adminSecretKeyHex

    const decrypted = eciesUnwrap(envelope, adminSecretKey, label)
    expect(bytesToHex(decrypted)).toBe(originalKeyHex)
  })

  test('JS can decrypt note produced by Rust (author key)', () => {
    const { encrypted, plaintextJson } = vectors.noteEncryption
    const authorSecretKey = vectors.keys.secretKeyHex

    const noteKey = eciesUnwrap(encrypted.authorEnvelope, authorSecretKey, labels.LABEL_NOTE_KEY)
    const decoded = decryptContent(encrypted.encryptedContent, noteKey)
    expect(decoded).toBe(plaintextJson)
  })

  test('JS can decrypt note produced by Rust (admin key)', () => {
    const { encrypted, plaintextJson } = vectors.noteEncryption
    const adminSecretKey = vectors.keys.adminSecretKeyHex
    const adminPubkey = vectors.keys.adminPublicKeyHex

    const adminEnvelope = encrypted.adminEnvelopes.find(
      (e: { pubkey: string }) => e.pubkey === adminPubkey,
    )
    expect(adminEnvelope).toBeDefined()

    const noteKey = eciesUnwrap(adminEnvelope, adminSecretKey, labels.LABEL_NOTE_KEY)
    const decoded = decryptContent(encrypted.encryptedContent, noteKey)
    expect(decoded).toBe(plaintextJson)
  })

  test('JS can verify auth token produced by Rust', () => {
    const { token, method, path } = vectors.auth

    // Reconstruct the message
    const message = `${labels.AUTH_PREFIX}${token.pubkey}:${token.timestamp}:${method}:${path}`
    const messageHash = sha256(utf8ToBytes(message))

    // Verify Schnorr signature -- v2: schnorr is a separate named export
    const valid = schnorr.verify(hexToBytes(token.token), messageHash, hexToBytes(token.pubkey))
    expect(valid).toBe(true)
  })

  test('JS can decrypt draft produced by Rust', () => {
    const { encryptedHex, secretKeyHex, plaintext } = vectors.draftEncryption

    // Draft encryption uses HKDF-derived key from the secret key
    // v2: HKDF requires Uint8Array for salt and info
    const hkdfKey = hkdf(sha256, hexToBytes(secretKeyHex), utf8ToBytes(labels.HKDF_SALT), utf8ToBytes(labels.HKDF_CONTEXT_DRAFTS), 32)

    // Parse: nonce(24) + ciphertext
    const packed = hexToBytes(encryptedHex)
    const nonce = packed.slice(0, 24)
    const ciphertext = packed.slice(24)

    const cipher = xchacha20poly1305(hkdfKey, nonce)
    const decrypted = cipher.decrypt(ciphertext)
    const decoded = new TextDecoder().decode(decrypted)

    expect(decoded).toBe(plaintext)
  })

  test('PIN encryption structure matches expected format', () => {
    const { encrypted, pin } = vectors.pinEncryption

    // Validate structure (don't decrypt -- PBKDF2 is slow)
    expect(encrypted.salt).toHaveLength(32) // 16 bytes hex
    expect(encrypted.nonce).toHaveLength(48) // 24 bytes hex
    expect(encrypted.iterations).toBe(600_000)
    expect(encrypted.ciphertext).toBeTruthy()
    expect(encrypted.pubkey).toBeTruthy()
    expect(pin).toBe('1234')
  })

  // --- v2 Tests ---

  test('JS can decrypt message produced by Rust (volunteer)', () => {
    const { encrypted, plaintext } = vectors.messageEncryption
    const volSecretKey = vectors.keys.secretKeyHex
    const volPubkey = vectors.keys.publicKeyHex

    // Find volunteer's envelope
    const volEnvelope = encrypted.readerEnvelopes.find(
      (e: { pubkey: string }) => e.pubkey === volPubkey,
    )
    expect(volEnvelope).toBeDefined()

    // Unwrap message key via ECIES with LABEL_MESSAGE
    const noteKey = eciesUnwrap(volEnvelope, volSecretKey, labels.LABEL_MESSAGE)

    // Decrypt content
    const decoded = decryptContent(encrypted.encryptedContent, noteKey)
    expect(decoded).toBe(plaintext)
  })

  test('JS can decrypt message produced by Rust (admin)', () => {
    const { encrypted, plaintext } = vectors.messageEncryption
    const adminSecretKey = vectors.keys.adminSecretKeyHex
    const adminPubkey = vectors.keys.adminPublicKeyHex

    const adminEnvelope = encrypted.readerEnvelopes.find(
      (e: { pubkey: string }) => e.pubkey === adminPubkey,
    )
    expect(adminEnvelope).toBeDefined()

    const msgKey = eciesUnwrap(adminEnvelope, adminSecretKey, labels.LABEL_MESSAGE)
    const decoded = decryptContent(encrypted.encryptedContent, msgKey)
    expect(decoded).toBe(plaintext)
  })

  test('JS can unwrap hub key produced by Rust', () => {
    const { hubKeyHex, wrappedEnvelopes, label } = vectors.hubKey
    const volSecretKey = vectors.keys.secretKeyHex

    // Unwrap first envelope (volunteer)
    const unwrapped = eciesUnwrap(wrappedEnvelopes[0], volSecretKey, label)
    expect(bytesToHex(unwrapped)).toBe(hubKeyHex)

    // Unwrap second envelope (admin)
    const adminUnwrapped = eciesUnwrap(
      wrappedEnvelopes[1],
      vectors.keys.adminSecretKeyHex,
      label,
    )
    expect(bytesToHex(adminUnwrapped)).toBe(hubKeyHex)
  })

  test('JS can verify Nostr event produced by Rust', () => {
    const { event, canonicalJson } = vectors.nostrEvent

    // Recompute event ID from canonical JSON
    const computedId = bytesToHex(sha256(utf8ToBytes(canonicalJson)))
    expect(computedId).toBe(event.id)

    // Verify BIP-340 Schnorr signature over the event ID
    const idHash = hexToBytes(event.id)
    const valid = schnorr.verify(hexToBytes(event.sig), idHash, hexToBytes(event.pubkey))
    expect(valid).toBe(true)

    // Verify canonical JSON structure matches NIP-01
    const parsed = JSON.parse(canonicalJson)
    expect(parsed[0]).toBe(0)
    expect(parsed[1]).toBe(event.pubkey)
    expect(parsed[2]).toBe(event.createdAt)
    expect(parsed[3]).toBe(event.kind)
  })

  test('JS can decrypt export produced by Rust', () => {
    const { encryptedBase64, secretKeyHex, plaintextJson } = vectors.exportEncryption

    // Derive key using HKDF with HKDF_CONTEXT_EXPORT
    const exportKey = hkdf(
      sha256,
      hexToBytes(secretKeyHex),
      utf8ToBytes(labels.HKDF_SALT),
      utf8ToBytes(labels.HKDF_CONTEXT_EXPORT),
      32,
    )

    // Decode base64 -> nonce(24) + ciphertext
    const packed = Uint8Array.from(Buffer.from(encryptedBase64, 'base64'))
    const nonce = packed.slice(0, 24)
    const ciphertext = packed.slice(24)

    const cipher = xchacha20poly1305(exportKey, nonce)
    const decrypted = cipher.decrypt(ciphertext)
    const decoded = new TextDecoder().decode(decrypted)

    expect(decoded).toBe(plaintextJson)
  })

  test('JS can decrypt call record produced by Rust (admin)', () => {
    const { encryptedContent, adminEnvelopes, plaintextJson } = vectors.callRecord
    const adminSecretKey = vectors.keys.adminSecretKeyHex
    const adminPubkey = vectors.keys.adminPublicKeyHex

    const adminEnvelope = adminEnvelopes.find(
      (e: { pubkey: string }) => e.pubkey === adminPubkey,
    )
    expect(adminEnvelope).toBeDefined()

    // Unwrap with LABEL_CALL_META (not LABEL_MESSAGE)
    const recordKey = eciesUnwrap(adminEnvelope, adminSecretKey, labels.LABEL_CALL_META)
    const decoded = decryptContent(encryptedContent, recordKey)
    expect(decoded).toBe(plaintextJson)
  })

  test('Domain separation prevents cross-label unwrap', () => {
    const { wrappedWithNoteLabel, wrappedWithMessageLabel, wrappedWithHubLabel } =
      vectors.domainSeparation
    const adminSecretKey = vectors.keys.adminSecretKeyHex

    // Same-label unwrap succeeds
    expect(() => eciesUnwrap(wrappedWithNoteLabel, adminSecretKey, labels.LABEL_NOTE_KEY)).not.toThrow()
    expect(() => eciesUnwrap(wrappedWithMessageLabel, adminSecretKey, labels.LABEL_MESSAGE)).not.toThrow()
    expect(() => eciesUnwrap(wrappedWithHubLabel, adminSecretKey, labels.LABEL_HUB_KEY_WRAP)).not.toThrow()

    // Cross-label unwrap fails (auth tag verification failure)
    expect(() => eciesUnwrap(wrappedWithNoteLabel, adminSecretKey, labels.LABEL_MESSAGE)).toThrow()
    expect(() => eciesUnwrap(wrappedWithMessageLabel, adminSecretKey, labels.LABEL_NOTE_KEY)).toThrow()
    expect(() => eciesUnwrap(wrappedWithHubLabel, adminSecretKey, labels.LABEL_NOTE_KEY)).toThrow()
  })

  // --- Adversarial Tests ---

  test('ECIES unwrap with tampered ciphertext throws', () => {
    const { tamperedWrappedKey, validEnvelope, validLabel } = vectors.adversarial.ecies
    const adminSecretKey = vectors.keys.adminSecretKeyHex

    const tamperedEnvelope = {
      wrappedKey: tamperedWrappedKey,
      ephemeralPubkey: validEnvelope.ephemeralPubkey,
    }
    expect(() => eciesUnwrap(tamperedEnvelope, adminSecretKey, validLabel)).toThrow()
  })

  test('ECIES unwrap with truncated data throws', () => {
    const { truncatedWrappedKey, validEnvelope, validLabel } = vectors.adversarial.ecies
    const adminSecretKey = vectors.keys.adminSecretKeyHex

    const truncatedEnvelope = {
      wrappedKey: truncatedWrappedKey,
      ephemeralPubkey: validEnvelope.ephemeralPubkey,
    }
    expect(() => eciesUnwrap(truncatedEnvelope, adminSecretKey, validLabel)).toThrow()
  })

  test('ECIES unwrap with wrong key throws', () => {
    const { validEnvelope, validLabel } = vectors.adversarial.ecies
    const wrongSecretKey = vectors.keys.wrongSecretKeyHex

    expect(() => eciesUnwrap(validEnvelope, wrongSecretKey, validLabel)).toThrow()
  })

  test('Note decrypt with tampered content throws', () => {
    const { validEncrypted, tamperedContent } = vectors.adversarial.note
    const authorSecretKey = vectors.keys.secretKeyHex

    // Unwrap the note key (should succeed)
    const noteKey = eciesUnwrap(
      validEncrypted.authorEnvelope,
      authorSecretKey,
      labels.LABEL_NOTE_KEY,
    )

    // Decrypt tampered content (should fail)
    const contentBytes = hexToBytes(tamperedContent)
    const contentNonce = contentBytes.slice(0, 24)
    const contentCiphertext = contentBytes.slice(24)

    expect(() => {
      const cipher = xchacha20poly1305(noteKey, contentNonce)
      cipher.decrypt(contentCiphertext)
    }).toThrow()
  })

  test('Auth token with wrong method fails verification', () => {
    const { validToken, validPath, wrongMethod } = vectors.adversarial.auth

    const message = `${labels.AUTH_PREFIX}${validToken.pubkey}:${validToken.timestamp}:${wrongMethod}:${validPath}`
    const messageHash = sha256(utf8ToBytes(message))
    const valid = schnorr.verify(hexToBytes(validToken.token), messageHash, hexToBytes(validToken.pubkey))
    expect(valid).toBe(false)
  })

  test('Auth token with wrong path fails verification', () => {
    const { validToken, validMethod, wrongPath } = vectors.adversarial.auth

    const message = `${labels.AUTH_PREFIX}${validToken.pubkey}:${validToken.timestamp}:${validMethod}:${wrongPath}`
    const messageHash = sha256(utf8ToBytes(message))
    const valid = schnorr.verify(hexToBytes(validToken.token), messageHash, hexToBytes(validToken.pubkey))
    expect(valid).toBe(false)
  })

  test('Message decrypt with wrong reader key fails', () => {
    const { validEncrypted } = vectors.adversarial.message
    const wrongPubkey = vectors.keys.wrongPublicKeyHex

    // Wrong key won't be found in envelopes
    const wrongEnvelope = validEncrypted.readerEnvelopes.find(
      (e: { pubkey: string }) => e.pubkey === wrongPubkey,
    )
    expect(wrongEnvelope).toBeUndefined()
  })
})
